// FILE: aheap.h// NAME:  Mark Sattolo#ifdef __GNUG__#pragma interface#endif#ifndef ARRAY_HEAP_H#define ARRAY_HEAP_H#include "heap.h"#include <iostream.h>// heap implemented as an arraytemplate<class data_type>class array_heap : public heap<data_type>{ private:	//===============================================================	// Subclass of heap<data_type>::handle -- it inherits the 'elem' variable	class a_node : public handle	 {	  public:		 // a variable to keep track of the array index of each a_node		 mutable int ind ;		 // constructor		 a_node( const data_type&, heap<data_type>::compare_fxn&, heap<data_type>::order&, int ) ;		 // assignment		 a_node& a_node::operator=( const a_node& a )  ;	 }; // class array_heap::a_node	//===============================================================	// print a node and all its sub-nodes	void print( ostream&, const a_node*, int = 0 ) const ; protected:	// the variables of array_heap	int max_size ;	a_node** array ;	// some useful methods	void swap( handle&, handle& ) ;	int left( int ) const ;	int right( int ) const ;	int parent( int ) const ;	int last() const ;	// pure virtual methods of parent class 'heap' are declared	void sift_up( handle& ) ;	void sift_down( handle& ) ;	handle& create_new( const data_type& ) ;	handle& first() ;	void move_last_to_first() ;	void delete_last() ;	handle& index( const handle& ) const ; public:	// constructor with default array size of 30	array_heap( compare_fxn, order, int = 30 ) ;	// copy constructor	array_heap( const array_heap<data_type>& ) ;	// assignment overload	array_heap<data_type>& operator=( const array_heap<data_type>& ) ;	// destructor	~array_heap() ;	// print	void print( ostream& ) const ;	// pure virtual method of parent class 'heap' declared here	const data_type& top() const ;};//class array_heap#endif // ARRAY_HEAP_H